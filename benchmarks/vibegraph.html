<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Benchmark Results</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
  <!-- Zoom plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.0" defer></script>
  <style>
    .chart-container canvas { min-height: 300px; }
    .toggle-switch { display: flex; align-items: center; margin-bottom: 0.5rem; gap: 1rem; }
    .toggle-switch input { margin-right: 0.5rem; }
    .reset-btn { padding: 0.25rem 0.75rem; background: #4299e1; color: white; border-radius: 0.375rem; cursor: pointer; }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 p-6">
  <div class="max-w-7xl mx-auto">
    <header class="mb-10">
      <h1 class="text-4xl font-bold">ParadeDB Benchmark Results</h1>
      <p class="text-gray-600 mt-2">Each bench is on its own graph.</p>
    </header>
    <div id="charts" class="space-y-12"></div>
  </div>

  <script>
    async function initCharts() {
      try {
        // Load new data.js
        const res = await fetch('https://paradedb.github.io/paradedb/benchmarks/data.js');
        const scriptText = await res.text(); eval(scriptText);
        Chart.register(ChartZoom);

        const rawData = window.BENCHMARK_DATA?.entries || {};
        const container = document.getElementById('charts');
        if (!Object.keys(rawData).length) {
          container.innerHTML = '<p class="text-red-500">No data.</p>';
          return;
        }

        // Collect all unique commit IDs
        const allEntries = Object.values(rawData).flat();
        const uniqueIds = Array.from(new Set(allEntries.map(e => e.commit.id)));
        const hashInfo = {};
        // Resolve PR info
        const fetchPrInfo = async () => {
          for (const fullId of uniqueIds) {
            const short = fullId.slice(0,7);
            try {
              const searchRes = await fetch(
                `https://api.github.com/search/issues?q=${short}+repo:paradedb/paradedb+type:pr`
              );
              const data = await searchRes.json();
              if (data.items && data.items.length) {
                const pr = data.items[0];
                hashInfo[short] = { label: `#${pr.number}: ${pr.title}`, url: pr.html_url };
              } else {
                hashInfo[short] = { label: short, url: null };
              }
            } catch {
              hashInfo[short] = { label: short, url: null };
            }
          }
        };
        await fetchPrInfo();

        // Group by config file basename
        const fileGroups = {};
        Object.entries(rawData).forEach(([category, entries]) => {
          const parts = category.split(' ');
          const filename = parts[1] || category;
          fileGroups[filename] = (fileGroups[filename] || []).concat(entries);
        });

        // For each file group, one graph per bench name
        Object.entries(fileGroups).forEach(([filename, entries]) => {
          const section = document.createElement('section');
          section.className = 'bg-white p-6 rounded-xl shadow-lg';
          const fileHeading = document.createElement('h2');
          fileHeading.className = 'text-2xl font-semibold mb-4';
          fileHeading.textContent = filename;
          section.appendChild(fileHeading);

          // Collect all runs sorted
          const runsMap = {};
          entries.forEach(entry => {
            const commitTs = new Date(entry.commit.timestamp).getTime();
            const runTs = entry.date;
            const hash = entry.commit.id.slice(0,7);
            entry.benches.forEach(b => {
              runsMap[`${commitTs}|${runTs}|${hash}`] = { commitTs, runTs, hash };
            });
          });
          const runs = Object.values(runsMap)
            .sort((a,b) => a.commitTs - b.commitTs || a.runTs - b.runTs);

          const fullLabels = runs.map(r => hashInfo[r.hash]?.label || r.hash);
          const labels = fullLabels.map(l => l.length > 25 ? l.slice(0,25) + 'â€¦' : l);
          const runUrls = runs.map(r => hashInfo[r.hash]?.url);

          // Group data by bench name
          const benchGroups = {};
          entries.forEach(entry => {
            const commitTs = new Date(entry.commit.timestamp).getTime();
            const runTs = entry.date;
            const hash = entry.commit.id.slice(0,7);
            entry.benches.forEach(b => {
              benchGroups[b.name] = benchGroups[b.name] || [];
              benchGroups[b.name].push({ commitTs, runTs, hash, value: b.value, unit: b.unit });
            });
          });

          Object.entries(benchGroups).forEach(([benchName, benchData]) => {
            const yLabel = benchData[0]?.unit || '';
            // Build data series aligned to runs
            const dataArr = runs.map(r => {
              const found = benchData.find(d => d.commitTs===r.commitTs && d.runTs===r.runTs && d.hash===r.hash);
              return found ? found.value : null;
            });

            // Graph heading
            const graphHeading = document.createElement('h3');
            graphHeading.className = 'text-xl font-semibold mt-6 mb-2';
            graphHeading.textContent = benchName;
            section.appendChild(graphHeading);

            // Controls & canvas
            const chartWrapper = document.createElement('div');
            chartWrapper.className = 'mb-8 chart-container';
            const toggleRow = document.createElement('div');
            toggleRow.className = 'toggle-switch';
            toggleRow.innerHTML = `
              <label><input type="checkbox" class="norm-toggle"/><span>Normalize to First Value</span></label>
              <label><input type="checkbox" class="yzero-toggle"/><span>Y Axis from Zero</span></label>
            `;
            chartWrapper.appendChild(toggleRow);
            const canvas = document.createElement('canvas');
            chartWrapper.appendChild(canvas);
            const btnRow = document.createElement('div');
            btnRow.className = 'flex justify-start mt-2';
            const resetBtn = document.createElement('button');
            resetBtn.textContent = 'Zoom Out';
            resetBtn.className = 'reset-btn';
            btnRow.appendChild(resetBtn);
            chartWrapper.appendChild(btnRow);
            section.appendChild(chartWrapper);

            // Initialize chart
            const chart = new Chart(canvas.getContext('2d'), {
              type: 'line',
              data: { labels, datasets: [{ label: benchName, data: dataArr, original: dataArr.slice(), fill: false, tension: 0.4, borderWidth: 2 }] },
              options: {
                responsive: true,
                scales: {
                  x: { ticks: { maxRotation: 33, minRotation: 33 } },
                  y: { title: { display: true, text: yLabel }, beginAtZero: false }
                },
                plugins: {
                  tooltip: {
                    mode: 'index', intersect: false,
                    callbacks: {
                      title: items => fullLabels[items[0].dataIndex],
                      label: ctx => {
                        const ds = ctx.dataset;
                        const raw = ds.original[ctx.dataIndex];
                        if (ctx.chart.normalized && ds.original[0]) {
                          const delta = ((raw - ds.original[0]) / ds.original[0]) * 100;
                          return `${delta>=0?'+':''}${delta.toFixed(0)}%`;
                        }
                        return `${raw}`;
                      }
                    }
                  },
                  zoom: { zoom: { drag: { enabled: true } } }
                },
                onClick: (evt, elements) => {
                  if (elements.length) {
                    const url = runUrls[elements[0].index];
                    if (url) window.open(url, '_blank');
                  }
                }
              }
            });
            chart.normalized = false;

            // Normalize toggle
            toggleRow.querySelector('.norm-toggle').addEventListener('change', e => {
              chart.resetZoom();
              chart.normalized = e.target.checked;
              chart.data.datasets.forEach(ds => {
                ds.data = chart.normalized && ds.original[0]
                  ? ds.original.map(v => v != null ? v / ds.original[0] : null)
                  : ds.original.slice();
              });
              chart.update();
            });
            // Y axis zero toggle
            toggleRow.querySelector('.yzero-toggle').addEventListener('change', e => {
              chart.options.scales.y.beginAtZero = e.target.checked;
              chart.resetZoom(); chart.update();
            });
            // Zoom out button
            resetBtn.addEventListener('click', () => chart.resetZoom());
            // Hide tooltip during drag
            canvas.addEventListener('mousedown', () => { chart.options.plugins.tooltip.enabled = false; chart.update('none'); });
            canvas.addEventListener('mouseup', () => { chart.options.plugins.tooltip.enabled = true; chart.update('none'); });
          });

          container.appendChild(section);
        });
      } catch (err) {
        console.error(err);
        document.getElementById('charts').innerHTML = '<p class="text-red-500">Failed to load benchmark data.</p>';
      }
    }
    document.addEventListener('DOMContentLoaded', initCharts);
  </script>
</body>
</html>
