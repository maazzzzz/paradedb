-- Test TopN + Aggregates + Faceting
-- Phase 1: Basic TopN tests with window aggregate detection
CREATE EXTENSION IF NOT EXISTS pg_search;
DROP TABLE IF EXISTS products CASCADE;
-- Setup test data
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    category TEXT,
    brand TEXT,
    price NUMERIC,
    rating NUMERIC,
    in_stock BOOLEAN,
    sales INTEGER
);
-- Insert test data
INSERT INTO products (name, description, category, brand, price, rating, in_stock, sales) VALUES
    ('MacBook Pro', 'High-performance laptop for professionals', 'Laptops', 'Apple', 2499, 4.8, true, 150),
    ('Dell XPS 13', 'Compact and powerful ultrabook', 'Laptops', 'Dell', 1299, 4.6, true, 200),
    ('ThinkPad X1', 'Business laptop with great keyboard', 'Laptops', 'Lenovo', 1599, 4.5, true, 180),
    ('HP Spectre', 'Stylish convertible laptop', 'Laptops', 'HP', 1399, 4.4, true, 120),
    ('ASUS ROG', 'Gaming laptop with RTX graphics', 'Laptops', 'ASUS', 1899, 4.7, true, 90);
-- Create BM25 index
CREATE INDEX products_idx ON products
USING bm25(id, name, description, category, brand, price, rating, in_stock, sales)
WITH (
    key_field='id',
    text_fields='{
        "name": {},
        "description": {},
        "brand": {"fast": true}
    }',
    numeric_fields='{
        "price": {"fast": true},
        "rating": {"fast": true},
        "sales": {"fast": true}
    }',
    boolean_fields='{
        "in_stock": {"fast": true}
    }'
);
-- Test 1: Basic TopN without window aggregates
\echo 'Test 1: Basic TopN query'
Test 1: Basic TopN query
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    category,
    rating
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, category, rating
   ->  Custom Scan (ParadeDB Scan) on public.products
         Output: id, name, category, rating
         Table: products
         Index: products_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Order By: rating desc
            TopN Limit: 3
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(11 rows)

SELECT 
    id,
    name,
    category,
    rating
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
 id |    name     | category | rating 
----+-------------+----------+--------
  1 | MacBook Pro | Laptops  |    4.8
  5 | ASUS ROG    | Laptops  |    4.7
  3 | ThinkPad X1 | Laptops  |    4.5
(3 rows)

-- Test 2: TopN with COUNT(*) OVER () - Basic window aggregate
\echo 'Test 2: TopN with COUNT(*) OVER () (basic window aggregate)'
Test 2: TopN with COUNT(*) OVER () (basic window aggregate)
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    rating,
    COUNT(*) OVER () as total_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, rating, (paradedb.window_func('{"target_entry_index":3,"result_type_oid":20,"window_spec":{"agg_type":{"CountAny":{"filter":null}},"partition_by":[],"order_by":null,"frame_clause":null}}'::text))
   ->  Custom Scan (ParadeDB Scan) on public.products
         Output: id, name, rating, paradedb.window_func('{"target_entry_index":3,"result_type_oid":20,"window_spec":{"agg_type":{"CountAny":{"filter":null}},"partition_by":[],"order_by":null,"frame_clause":null}}'::text)
         Table: products
         Index: products_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Order By: rating desc
            TopN Limit: 3
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(11 rows)

SELECT 
    id,
    name,
    rating,
    COUNT(*) OVER () as total_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
 id |    name     | rating | total_count 
----+-------------+--------+-------------
  1 | MacBook Pro |    4.8 |           4
  5 | ASUS ROG    |    4.7 |           4
  3 | ThinkPad X1 |    4.5 |           4
(3 rows)

-- Test 3: Multiple window aggregates (COUNT, SUM, AVG)
\echo 'Test 3: Multiple window aggregates in one query'
Test 3: Multiple window aggregates in one query
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    rating,
    price,
    COUNT(*) OVER () as total_count,
    SUM(price) OVER () as total_price,
    AVG(rating) OVER () as avg_rating
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, rating, price, (count(*) OVER (?)), (sum(price) OVER (?)), (avg(rating) OVER (?))
   ->  Sort
         Output: id, name, rating, price, (count(*) OVER (?)), (sum(price) OVER (?)), (avg(rating) OVER (?))
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, rating, price, count(*) OVER (?), sum(price) OVER (?), avg(rating) OVER (?)
               ->  Custom Scan (ParadeDB Scan) on public.products
                     Output: id, name, rating, price
                     Table: products
                     Index: products_idx
                     Exec Method: NormalScanExecState
                     Scores: false
                     Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(14 rows)

SELECT 
    id,
    name,
    rating,
    price,
    COUNT(*) OVER () as total_count,
    SUM(price) OVER () as total_price,
    AVG(rating) OVER () as avg_rating
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
 id |    name     | rating | price | total_count | total_price |     avg_rating     
----+-------------+--------+-------+-------------+-------------+--------------------
  1 | MacBook Pro |    4.8 |  2499 |           4 |        7396 | 4.6000000000000000
  5 | ASUS ROG    |    4.7 |  1899 |           4 |        7396 | 4.6000000000000000
  3 | ThinkPad X1 |    4.5 |  1599 |           4 |        7396 | 4.6000000000000000
(3 rows)

-- Test 4: Window aggregate with PARTITION BY (not supported yet, but should extract)
\echo 'Test 4: COUNT with PARTITION BY category'
Test 4: COUNT with PARTITION BY category
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    category,
    rating,
    COUNT(*) OVER (PARTITION BY category) as category_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, category, rating, (count(*) OVER (?))
   ->  Sort
         Output: id, name, category, rating, (count(*) OVER (?))
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, category, rating, count(*) OVER (?)
               ->  Sort
                     Output: category, id, name, rating
                     Sort Key: products.category
                     ->  Custom Scan (ParadeDB Scan) on public.products
                           Output: category, id, name, rating
                           Table: products
                           Index: products_idx
                           Exec Method: NormalScanExecState
                           Scores: false
                           Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(17 rows)

-- Test 5: Window aggregate with ORDER BY in OVER clause
\echo 'Test 5: SUM with ORDER BY in OVER clause (running total)'
Test 5: SUM with ORDER BY in OVER clause (running total)
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    rating,
    price,
    SUM(price) OVER (ORDER BY rating DESC) as running_total
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, rating, price, (sum(price) OVER (?))
   ->  WindowAgg
         Output: id, name, rating, price, sum(price) OVER (?)
         ->  Sort
               Output: rating, id, name, price
               Sort Key: products.rating DESC
               ->  Custom Scan (ParadeDB Scan) on public.products
                     Output: rating, id, name, price
                     Table: products
                     Index: products_idx
                     Exec Method: NormalScanExecState
                     Scores: false
                     Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(14 rows)

-- Test 6: Window aggregate with ROWS frame
\echo 'Test 6: AVG with ROWS frame'
Test 6: AVG with ROWS frame
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    rating,
    AVG(rating) OVER (ORDER BY rating DESC ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) as moving_avg
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, rating, (avg(rating) OVER (?))
   ->  WindowAgg
         Output: id, name, rating, avg(rating) OVER (?)
         ->  Sort
               Output: rating, id, name
               Sort Key: products.rating DESC
               ->  Custom Scan (ParadeDB Scan) on public.products
                     Output: rating, id, name
                     Table: products
                     Index: products_idx
                     Exec Method: NormalScanExecState
                     Scores: false
                     Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(14 rows)

-- Test 7: MIN and MAX window aggregates
\echo 'Test 7: MIN and MAX aggregates'
Test 7: MIN and MAX aggregates
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    rating,
    price,
    MIN(price) OVER () as min_price,
    MAX(price) OVER () as max_price
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, rating, price, (min(price) OVER (?)), (max(price) OVER (?))
   ->  Sort
         Output: id, name, rating, price, (min(price) OVER (?)), (max(price) OVER (?))
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, rating, price, min(price) OVER (?), max(price) OVER (?)
               ->  Custom Scan (ParadeDB Scan) on public.products
                     Output: id, name, rating, price
                     Table: products
                     Index: products_idx
                     Exec Method: NormalScanExecState
                     Scores: false
                     Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(14 rows)

SELECT 
    id,
    name,
    rating,
    price,
    MIN(price) OVER () as min_price,
    MAX(price) OVER () as max_price
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
 id |    name     | rating | price | min_price | max_price 
----+-------------+--------+-------+-----------+-----------
  1 | MacBook Pro |    4.8 |  2499 |      1399 |      2499
  5 | ASUS ROG    |    4.7 |  1899 |      1399 |      2499
  3 | ThinkPad X1 |    4.5 |  1599 |      1399 |      2499
(3 rows)

-- Test 8: Window aggregate with FILTER clause
\echo 'Test 8: COUNT with FILTER clause'
Test 8: COUNT with FILTER clause
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    rating,
    in_stock,
    COUNT(*) FILTER (WHERE in_stock = true) OVER () as in_stock_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, rating, in_stock, (count(*) FILTER (WHERE in_stock) OVER (?))
   ->  Sort
         Output: id, name, rating, in_stock, (count(*) FILTER (WHERE in_stock) OVER (?))
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, rating, in_stock, count(*) FILTER (WHERE in_stock) OVER (?)
               ->  Custom Scan (ParadeDB Scan) on public.products
                     Output: id, name, rating, in_stock
                     Table: products
                     Index: products_idx
                     Exec Method: NormalScanExecState
                     Scores: false
                     Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(14 rows)

-- Test 9: COUNT with specific column (not *)
\echo 'Test 9: COUNT(column) instead of COUNT(*)'
Test 9: COUNT(column) instead of COUNT(*)
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    rating,
    COUNT(brand) OVER () as brand_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, rating, (count(brand) OVER (?))
   ->  Sort
         Output: id, name, rating, (count(brand) OVER (?))
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, rating, count(brand) OVER (?)
               ->  Custom Scan (ParadeDB Scan) on public.products
                     Output: id, name, rating, brand
                     Table: products
                     Index: products_idx
                     Exec Method: NormalScanExecState
                     Scores: false
                     Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(14 rows)

-- Test 10: Complex PARTITION BY and ORDER BY combination
\echo 'Test 10: Complex window with PARTITION BY and ORDER BY'
Test 10: Complex window with PARTITION BY and ORDER BY
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    category,
    brand,
    rating,
    COUNT(*) OVER (PARTITION BY category ORDER BY rating DESC) as category_rank_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, category, brand, rating, (count(*) OVER (?))
   ->  Sort
         Output: id, name, category, brand, rating, (count(*) OVER (?))
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, category, brand, rating, count(*) OVER (?)
               ->  Sort
                     Output: category, rating, id, name, brand
                     Sort Key: products.category, products.rating DESC
                     ->  Custom Scan (ParadeDB Scan) on public.products
                           Output: category, rating, id, name, brand
                           Table: products
                           Index: products_idx
                           Exec Method: NormalScanExecState
                           Scores: false
                           Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(17 rows)

-- Test 11: Window aggregate without ORDER BY on base query
\echo 'Test 11: Window aggregate without ORDER BY or LIMIT'
Test 11: Window aggregate without ORDER BY or LIMIT
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    rating,
    COUNT(*) OVER () as total_count
FROM products
WHERE description @@@ 'laptop';
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 WindowAgg
   Output: id, name, rating, count(*) OVER (?)
   ->  Custom Scan (ParadeDB Scan) on public.products
         Output: id, name, rating
         Table: products
         Index: products_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(9 rows)

SELECT 
    id,
    name,
    rating,
    COUNT(*) OVER () as total_count
FROM products
WHERE description @@@ 'laptop';
 id |    name     | rating | total_count 
----+-------------+--------+-------------
  1 | MacBook Pro |    4.8 |           4
  3 | ThinkPad X1 |    4.5 |           4
  4 | HP Spectre  |    4.4 |           4
  5 | ASUS ROG    |    4.7 |           4
(4 rows)

-- Test 12: Window aggregate with RANGE frame
\echo 'Test 12: SUM with RANGE frame'
Test 12: SUM with RANGE frame
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    rating,
    price,
    SUM(price) OVER (ORDER BY rating RANGE BETWEEN 0.5 PRECEDING AND 0.5 FOLLOWING) as range_sum
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, rating, price, (sum(price) OVER (?))
   ->  Sort
         Output: id, name, rating, price, (sum(price) OVER (?))
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, rating, price, sum(price) OVER (?)
               ->  Sort
                     Output: rating, id, name, price
                     Sort Key: products.rating
                     ->  Custom Scan (ParadeDB Scan) on public.products
                           Output: rating, id, name, price
                           Table: products
                           Index: products_idx
                           Exec Method: NormalScanExecState
                           Scores: false
                           Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(17 rows)

-- Test 13: Multiple different PARTITION BY clauses
\echo 'Test 13: Multiple window functions with different partitions'
Test 13: Multiple window functions with different partitions
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    category,
    brand,
    rating,
    COUNT(*) OVER (PARTITION BY category) as by_category,
    COUNT(*) OVER (PARTITION BY brand) as by_brand,
    COUNT(*) OVER () as total
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, category, brand, rating, (count(*) OVER (?)), (count(*) OVER (?)), (count(*) OVER (?))
   ->  Sort
         Output: id, name, category, brand, rating, (count(*) OVER (?)), (count(*) OVER (?)), (count(*) OVER (?))
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, category, brand, rating, (count(*) OVER (?)), (count(*) OVER (?)), count(*) OVER (?)
               ->  WindowAgg
                     Output: category, brand, id, name, rating, (count(*) OVER (?)), count(*) OVER (?)
                     ->  Sort
                           Output: category, brand, id, name, rating, (count(*) OVER (?))
                           Sort Key: products.category
                           ->  WindowAgg
                                 Output: category, brand, id, name, rating, count(*) OVER (?)
                                 ->  Sort
                                       Output: category, brand, id, name, rating
                                       Sort Key: products.brand
                                       ->  Custom Scan (ParadeDB Scan) on public.products
                                             Output: category, brand, id, name, rating
                                             Table: products
                                             Index: products_idx
                                             Exec Method: NormalScanExecState
                                             Scores: false
                                             Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(24 rows)

-- Test 14: Window aggregate with GROUPS frame (PG17+)
\echo 'Test 14: COUNT with GROUPS frame'
Test 14: COUNT with GROUPS frame
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    rating,
    COUNT(*) OVER (ORDER BY rating GROUPS BETWEEN 1 PRECEDING AND CURRENT ROW) as group_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, rating, (count(*) OVER (?))
   ->  Sort
         Output: id, name, rating, (count(*) OVER (?))
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, rating, count(*) OVER (?)
               ->  Sort
                     Output: rating, id, name
                     Sort Key: products.rating
                     ->  Custom Scan (ParadeDB Scan) on public.products
                           Output: rating, id, name
                           Table: products
                           Index: products_idx
                           Exec Method: NormalScanExecState
                           Scores: false
                           Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(17 rows)

-- Test 15: TopN with no @@@ operator (should not trigger window function handling)
\echo 'Test 15: Window aggregate without @@@ operator (should use standard WindowAgg)'
Test 15: Window aggregate without @@@ operator (should use standard WindowAgg)
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    rating,
    COUNT(*) OVER () as total_count
FROM products
WHERE rating > 4.5
ORDER BY rating DESC
LIMIT 3;
                        QUERY PLAN                         
-----------------------------------------------------------
 Limit
   Output: id, name, rating, (count(*) OVER (?))
   ->  Sort
         Output: id, name, rating, (count(*) OVER (?))
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, rating, count(*) OVER (?)
               ->  Seq Scan on public.products
                     Output: id, name, rating
                     Filter: (products.rating > 4.5)
(10 rows)

SELECT 
    id,
    name,
    rating,
    COUNT(*) OVER () as total_count
FROM products
WHERE rating > 4.5
ORDER BY rating DESC
LIMIT 3;
 id |    name     | rating | total_count 
----+-------------+--------+-------------
  1 | MacBook Pro |    4.8 |           3
  5 | ASUS ROG    |    4.7 |           3
  2 | Dell XPS 13 |    4.6 |           3
(3 rows)

-- Test 16: Window aggregate with multiple base table columns
\echo 'Test 16: Window aggregate with all result columns'
Test 16: Window aggregate with all result columns
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    category,
    brand,
    price,
    rating,
    sales,
    COUNT(*) OVER () as total_count,
    SUM(sales) OVER () as total_sales
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 2;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, category, brand, price, rating, sales, (count(*) OVER (?)), (sum(sales) OVER (?))
   ->  Sort
         Output: id, name, category, brand, price, rating, sales, (count(*) OVER (?)), (sum(sales) OVER (?))
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, category, brand, price, rating, sales, count(*) OVER (?), sum(sales) OVER (?)
               ->  Custom Scan (ParadeDB Scan) on public.products
                     Output: id, name, category, brand, price, rating, sales
                     Table: products
                     Index: products_idx
                     Exec Method: NormalScanExecState
                     Scores: false
                     Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(14 rows)

SELECT 
    id,
    name,
    category,
    brand,
    price,
    rating,
    sales,
    COUNT(*) OVER () as total_count,
    SUM(sales) OVER () as total_sales
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 2;
 id |    name     | category | brand | price | rating | sales | total_count | total_sales 
----+-------------+----------+-------+-------+--------+-------+-------------+-------------
  1 | MacBook Pro | Laptops  | Apple |  2499 |    4.8 |   150 |           4 |         540
  5 | ASUS ROG    | Laptops  | ASUS  |  1899 |    4.7 |    90 |           4 |         540
(2 rows)

-- Test 17: Window aggregate in a subquery (TopN in outer query)
\echo 'Test 17: Subquery with window aggregate, outer LIMIT'
Test 17: Subquery with window aggregate, outer LIMIT
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT * FROM (
    SELECT 
        id,
        name,
        rating,
        price,
        COUNT(*) OVER () as total_count
    FROM products
    WHERE description @@@ 'laptop'
    ORDER BY rating DESC
    LIMIT 5
) sub
ORDER BY price DESC
LIMIT 2;
ERROR:  Should find bm25_index when query has @@@ operator
SELECT * FROM (
    SELECT 
        id,
        name,
        rating,
        price,
        COUNT(*) OVER () as total_count
    FROM products
    WHERE description @@@ 'laptop'
    ORDER BY rating DESC
    LIMIT 5
) sub
ORDER BY price DESC
LIMIT 2;
ERROR:  Should find bm25_index when query has @@@ operator
-- Test 18: Value Facet - Category distribution (like Elasticsearch value facets)
\echo 'Test 18: TopN with category facet (value facet pattern)'
Test 18: TopN with category facet (value facet pattern)
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    category,
    rating,
    COUNT(*) OVER () as total_results,
    COUNT(*) OVER (PARTITION BY category) as category_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, category, rating, (count(*) OVER (?)), (count(*) OVER (?))
   ->  Sort
         Output: id, name, category, rating, (count(*) OVER (?)), (count(*) OVER (?))
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, category, rating, count(*) OVER (?), (count(*) OVER (?))
               ->  WindowAgg
                     Output: category, id, name, rating, count(*) OVER (?)
                     ->  Sort
                           Output: category, id, name, rating
                           Sort Key: products.category
                           ->  Custom Scan (ParadeDB Scan) on public.products
                                 Output: category, id, name, rating
                                 Table: products
                                 Index: products_idx
                                 Exec Method: NormalScanExecState
                                 Scores: false
                                 Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(19 rows)

SELECT 
    id,
    name,
    category,
    rating,
    COUNT(*) OVER () as total_results,
    COUNT(*) OVER (PARTITION BY category) as category_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
 id |    name     | category | rating | total_results | category_count 
----+-------------+----------+--------+---------------+----------------
  1 | MacBook Pro | Laptops  |    4.8 |             4 |              4
  5 | ASUS ROG    | Laptops  |    4.7 |             4 |              4
  3 | ThinkPad X1 | Laptops  |    4.5 |             4 |              4
(3 rows)

-- Test 19: Range Facet - Price buckets (like Elasticsearch range facets)
\echo 'Test 19: TopN with price range buckets'
Test 19: TopN with price range buckets
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    price,
    CASE 
        WHEN price < 1000 THEN 'Budget'
        WHEN price < 1500 THEN 'Mid-range'
        ELSE 'Premium'
    END as price_bucket,
    COUNT(*) OVER () as total_results,
    COUNT(*) OVER (PARTITION BY CASE 
        WHEN price < 1000 THEN 'Budget'
        WHEN price < 1500 THEN 'Mid-range'
        ELSE 'Premium'
    END) as bucket_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 5;
                                                                                                           QUERY PLAN                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, price, (CASE WHEN (price < '1000'::numeric) THEN 'Budget'::text WHEN (price < '1500'::numeric) THEN 'Mid-range'::text ELSE 'Premium'::text END), (count(*) OVER (?)), (count(*) OVER (?)), rating
   ->  Sort
         Output: id, name, price, (CASE WHEN (price < '1000'::numeric) THEN 'Budget'::text WHEN (price < '1500'::numeric) THEN 'Mid-range'::text ELSE 'Premium'::text END), (count(*) OVER (?)), (count(*) OVER (?)), rating
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, price, (CASE WHEN (price < '1000'::numeric) THEN 'Budget'::text WHEN (price < '1500'::numeric) THEN 'Mid-range'::text ELSE 'Premium'::text END), count(*) OVER (?), (count(*) OVER (?)), rating
               ->  WindowAgg
                     Output: (CASE WHEN (price < '1000'::numeric) THEN 'Budget'::text WHEN (price < '1500'::numeric) THEN 'Mid-range'::text ELSE 'Premium'::text END), id, name, price, rating, count(*) OVER (?)
                     ->  Sort
                           Output: (CASE WHEN (price < '1000'::numeric) THEN 'Budget'::text WHEN (price < '1500'::numeric) THEN 'Mid-range'::text ELSE 'Premium'::text END), id, name, price, rating
                           Sort Key: (CASE WHEN (products.price < '1000'::numeric) THEN 'Budget'::text WHEN (products.price < '1500'::numeric) THEN 'Mid-range'::text ELSE 'Premium'::text END)
                           ->  Custom Scan (ParadeDB Scan) on public.products
                                 Output: CASE WHEN (price < '1000'::numeric) THEN 'Budget'::text WHEN (price < '1500'::numeric) THEN 'Mid-range'::text ELSE 'Premium'::text END, id, name, price, rating
                                 Table: products
                                 Index: products_idx
                                 Exec Method: NormalScanExecState
                                 Scores: false
                                 Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(19 rows)

SELECT 
    id,
    name,
    price,
    CASE 
        WHEN price < 1000 THEN 'Budget'
        WHEN price < 1500 THEN 'Mid-range'
        ELSE 'Premium'
    END as price_bucket,
    COUNT(*) OVER () as total_results,
    COUNT(*) OVER (PARTITION BY CASE 
        WHEN price < 1000 THEN 'Budget'
        WHEN price < 1500 THEN 'Mid-range'
        ELSE 'Premium'
    END) as bucket_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 5;
 id |    name     | price | price_bucket | total_results | bucket_count 
----+-------------+-------+--------------+---------------+--------------
  1 | MacBook Pro |  2499 | Premium      |             4 |            3
  5 | ASUS ROG    |  1899 | Premium      |             4 |            3
  3 | ThinkPad X1 |  1599 | Premium      |             4 |            3
  4 | HP Spectre  |  1399 | Mid-range    |             4 |            1
(4 rows)

-- Test 20: Multi-facet - Brand + Price range (combining multiple facets)
\echo 'Test 20: TopN with multiple facets (brand + price range)'
Test 20: TopN with multiple facets (brand + price range)
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    brand,
    price,
    COUNT(*) OVER () as total_results,
    COUNT(*) OVER (PARTITION BY brand) as brand_count,
    AVG(price) OVER (PARTITION BY brand) as avg_brand_price
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, brand, price, (count(*) OVER (?)), (count(*) OVER (?)), (avg(price) OVER (?)), rating
   ->  Sort
         Output: id, name, brand, price, (count(*) OVER (?)), (count(*) OVER (?)), (avg(price) OVER (?)), rating
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, brand, price, count(*) OVER (?), (count(*) OVER (?)), (avg(price) OVER (?)), rating
               ->  WindowAgg
                     Output: brand, id, name, price, rating, count(*) OVER (?), avg(price) OVER (?)
                     ->  Sort
                           Output: brand, id, name, price, rating
                           Sort Key: products.brand
                           ->  Custom Scan (ParadeDB Scan) on public.products
                                 Output: brand, id, name, price, rating
                                 Table: products
                                 Index: products_idx
                                 Exec Method: NormalScanExecState
                                 Scores: false
                                 Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(19 rows)

SELECT 
    id,
    name,
    brand,
    price,
    COUNT(*) OVER () as total_results,
    COUNT(*) OVER (PARTITION BY brand) as brand_count,
    AVG(price) OVER (PARTITION BY brand) as avg_brand_price
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
 id |    name     | brand  | price | total_results | brand_count |    avg_brand_price    
----+-------------+--------+-------+---------------+-------------+-----------------------
  1 | MacBook Pro | Apple  |  2499 |             4 |           1 | 2499.0000000000000000
  5 | ASUS ROG    | ASUS   |  1899 |             4 |           1 | 1899.0000000000000000
  3 | ThinkPad X1 | Lenovo |  1599 |             4 |           1 | 1599.0000000000000000
(3 rows)

-- Test 21: Facet with aggregates - MIN/MAX price per category
\echo 'Test 21: TopN with MIN/MAX aggregates per category'
Test 21: TopN with MIN/MAX aggregates per category
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    category,
    price,
    COUNT(*) OVER () as total_results,
    MIN(price) OVER (PARTITION BY category) as category_min_price,
    MAX(price) OVER (PARTITION BY category) as category_max_price
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, category, price, (count(*) OVER (?)), (min(price) OVER (?)), (max(price) OVER (?)), rating
   ->  Sort
         Output: id, name, category, price, (count(*) OVER (?)), (min(price) OVER (?)), (max(price) OVER (?)), rating
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, category, price, count(*) OVER (?), (min(price) OVER (?)), (max(price) OVER (?)), rating
               ->  WindowAgg
                     Output: category, id, name, price, rating, min(price) OVER (?), max(price) OVER (?)
                     ->  Sort
                           Output: category, id, name, price, rating
                           Sort Key: products.category
                           ->  Custom Scan (ParadeDB Scan) on public.products
                                 Output: category, id, name, price, rating
                                 Table: products
                                 Index: products_idx
                                 Exec Method: NormalScanExecState
                                 Scores: false
                                 Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(19 rows)

SELECT 
    id,
    name,
    category,
    price,
    COUNT(*) OVER () as total_results,
    MIN(price) OVER (PARTITION BY category) as category_min_price,
    MAX(price) OVER (PARTITION BY category) as category_max_price
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
 id |    name     | category | price | total_results | category_min_price | category_max_price 
----+-------------+----------+-------+---------------+--------------------+--------------------
  1 | MacBook Pro | Laptops  |  2499 |             4 |               1399 |               2499
  5 | ASUS ROG    | Laptops  |  1899 |             4 |               1399 |               2499
  3 | ThinkPad X1 | Laptops  |  1599 |             4 |               1399 |               2499
(3 rows)

-- Test 22: Boolean facet - In-stock availability
\echo 'Test 22: TopN with boolean facet (in_stock)'
Test 22: TopN with boolean facet (in_stock)
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    in_stock,
    COUNT(*) OVER () as total_results,
    COUNT(*) OVER (PARTITION BY in_stock) as stock_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, in_stock, (count(*) OVER (?)), (count(*) OVER (?)), rating
   ->  Sort
         Output: id, name, in_stock, (count(*) OVER (?)), (count(*) OVER (?)), rating
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, in_stock, count(*) OVER (?), (count(*) OVER (?)), rating
               ->  WindowAgg
                     Output: in_stock, id, name, rating, count(*) OVER (?)
                     ->  Sort
                           Output: in_stock, id, name, rating
                           Sort Key: products.in_stock
                           ->  Custom Scan (ParadeDB Scan) on public.products
                                 Output: in_stock, id, name, rating
                                 Table: products
                                 Index: products_idx
                                 Exec Method: NormalScanExecState
                                 Scores: false
                                 Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(19 rows)

SELECT 
    id,
    name,
    in_stock,
    COUNT(*) OVER () as total_results,
    COUNT(*) OVER (PARTITION BY in_stock) as stock_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
 id |    name     | in_stock | total_results | stock_count 
----+-------------+----------+---------------+-------------
  1 | MacBook Pro | t        |             4 |           4
  5 | ASUS ROG    | t        |             4 |           4
  3 | ThinkPad X1 | t        |             4 |           4
(3 rows)

-- Test 23: Popularity facet - Sales volume buckets
\echo 'Test 23: TopN with sales volume facets'
Test 23: TopN with sales volume facets
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    sales,
    CASE 
        WHEN sales < 100 THEN 'Low'
        WHEN sales < 150 THEN 'Medium'
        ELSE 'High'
    END as sales_volume,
    COUNT(*) OVER () as total_results,
    SUM(sales) OVER () as total_sales
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                                          QUERY PLAN                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, sales, (CASE WHEN (sales < 100) THEN 'Low'::text WHEN (sales < 150) THEN 'Medium'::text ELSE 'High'::text END), (count(*) OVER (?)), (sum(sales) OVER (?)), rating
   ->  Sort
         Output: id, name, sales, (CASE WHEN (sales < 100) THEN 'Low'::text WHEN (sales < 150) THEN 'Medium'::text ELSE 'High'::text END), (count(*) OVER (?)), (sum(sales) OVER (?)), rating
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, sales, CASE WHEN (sales < 100) THEN 'Low'::text WHEN (sales < 150) THEN 'Medium'::text ELSE 'High'::text END, count(*) OVER (?), sum(sales) OVER (?), rating
               ->  Custom Scan (ParadeDB Scan) on public.products
                     Output: id, name, sales, rating
                     Table: products
                     Index: products_idx
                     Exec Method: NormalScanExecState
                     Scores: false
                     Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(14 rows)

SELECT 
    id,
    name,
    sales,
    CASE 
        WHEN sales < 100 THEN 'Low'
        WHEN sales < 150 THEN 'Medium'
        ELSE 'High'
    END as sales_volume,
    COUNT(*) OVER () as total_results,
    SUM(sales) OVER () as total_sales
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
 id |    name     | sales | sales_volume | total_results | total_sales 
----+-------------+-------+--------------+---------------+-------------
  1 | MacBook Pro |   150 | High         |             4 |         540
  5 | ASUS ROG    |    90 | Low          |             4 |         540
  3 | ThinkPad X1 |   180 | High         |             4 |         540
(3 rows)

-- Test 24: Rating histogram - Rating distribution
\echo 'Test 24: TopN with rating distribution histogram'
Test 24: TopN with rating distribution histogram
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    rating,
    CASE 
        WHEN rating >= 4.7 THEN 'Excellent (4.7+)'
        WHEN rating >= 4.5 THEN 'Very Good (4.5-4.7)'
        WHEN rating >= 4.0 THEN 'Good (4.0-4.5)'
        ELSE 'Fair (<4.0)'
    END as rating_tier,
    COUNT(*) OVER () as total_results,
    COUNT(*) OVER (PARTITION BY CASE 
        WHEN rating >= 4.7 THEN 'Excellent (4.7+)'
        WHEN rating >= 4.5 THEN 'Very Good (4.5-4.7)'
        WHEN rating >= 4.0 THEN 'Good (4.0-4.5)'
        ELSE 'Fair (<4.0)'
    END) as tier_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 5;
                                                                                                                                  QUERY PLAN                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, rating, (CASE WHEN (rating >= 4.7) THEN 'Excellent (4.7+)'::text WHEN (rating >= 4.5) THEN 'Very Good (4.5-4.7)'::text WHEN (rating >= 4.0) THEN 'Good (4.0-4.5)'::text ELSE 'Fair (<4.0)'::text END), (count(*) OVER (?)), (count(*) OVER (?))
   ->  Sort
         Output: id, name, rating, (CASE WHEN (rating >= 4.7) THEN 'Excellent (4.7+)'::text WHEN (rating >= 4.5) THEN 'Very Good (4.5-4.7)'::text WHEN (rating >= 4.0) THEN 'Good (4.0-4.5)'::text ELSE 'Fair (<4.0)'::text END), (count(*) OVER (?)), (count(*) OVER (?))
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, rating, (CASE WHEN (rating >= 4.7) THEN 'Excellent (4.7+)'::text WHEN (rating >= 4.5) THEN 'Very Good (4.5-4.7)'::text WHEN (rating >= 4.0) THEN 'Good (4.0-4.5)'::text ELSE 'Fair (<4.0)'::text END), count(*) OVER (?), (count(*) OVER (?))
               ->  WindowAgg
                     Output: (CASE WHEN (rating >= 4.7) THEN 'Excellent (4.7+)'::text WHEN (rating >= 4.5) THEN 'Very Good (4.5-4.7)'::text WHEN (rating >= 4.0) THEN 'Good (4.0-4.5)'::text ELSE 'Fair (<4.0)'::text END), id, name, rating, count(*) OVER (?)
                     ->  Sort
                           Output: (CASE WHEN (rating >= 4.7) THEN 'Excellent (4.7+)'::text WHEN (rating >= 4.5) THEN 'Very Good (4.5-4.7)'::text WHEN (rating >= 4.0) THEN 'Good (4.0-4.5)'::text ELSE 'Fair (<4.0)'::text END), id, name, rating
                           Sort Key: (CASE WHEN (products.rating >= 4.7) THEN 'Excellent (4.7+)'::text WHEN (products.rating >= 4.5) THEN 'Very Good (4.5-4.7)'::text WHEN (products.rating >= 4.0) THEN 'Good (4.0-4.5)'::text ELSE 'Fair (<4.0)'::text END)
                           ->  Custom Scan (ParadeDB Scan) on public.products
                                 Output: CASE WHEN (rating >= 4.7) THEN 'Excellent (4.7+)'::text WHEN (rating >= 4.5) THEN 'Very Good (4.5-4.7)'::text WHEN (rating >= 4.0) THEN 'Good (4.0-4.5)'::text ELSE 'Fair (<4.0)'::text END, id, name, rating
                                 Table: products
                                 Index: products_idx
                                 Exec Method: NormalScanExecState
                                 Scores: false
                                 Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(19 rows)

SELECT 
    id,
    name,
    rating,
    CASE 
        WHEN rating >= 4.7 THEN 'Excellent (4.7+)'
        WHEN rating >= 4.5 THEN 'Very Good (4.5-4.7)'
        WHEN rating >= 4.0 THEN 'Good (4.0-4.5)'
        ELSE 'Fair (<4.0)'
    END as rating_tier,
    COUNT(*) OVER () as total_results,
    COUNT(*) OVER (PARTITION BY CASE 
        WHEN rating >= 4.7 THEN 'Excellent (4.7+)'
        WHEN rating >= 4.5 THEN 'Very Good (4.5-4.7)'
        WHEN rating >= 4.0 THEN 'Good (4.0-4.5)'
        ELSE 'Fair (<4.0)'
    END) as tier_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 5;
 id |    name     | rating |     rating_tier     | total_results | tier_count 
----+-------------+--------+---------------------+---------------+------------
  1 | MacBook Pro |    4.8 | Excellent (4.7+)    |             4 |          2
  5 | ASUS ROG    |    4.7 | Excellent (4.7+)    |             4 |          2
  3 | ThinkPad X1 |    4.5 | Very Good (4.5-4.7) |             4 |          1
  4 | HP Spectre  |    4.4 | Good (4.0-4.5)      |             4 |          1
(4 rows)

-- Test 25: Complete faceting scenario - Combining all facet types
\echo 'Test 25: Complete e-commerce faceting (brand, price, rating, stock)'
Test 25: Complete e-commerce faceting (brand, price, rating, stock)
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT 
    id,
    name,
    brand,
    price,
    rating,
    in_stock,
    -- Overall metrics
    COUNT(*) OVER () as total_results,
    AVG(price) OVER () as avg_price,
    AVG(rating) OVER () as avg_rating,
    -- Brand facets
    COUNT(*) OVER (PARTITION BY brand) as brand_count,
    -- Price range facets
    COUNT(*) OVER (PARTITION BY CASE 
        WHEN price < 1500 THEN 'Under $1500'
        ELSE '$1500+'
    END) as price_range_count,
    -- Stock facets
    COUNT(*) OVER (PARTITION BY in_stock) as stock_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
                                                                                                                                     QUERY PLAN                                                                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, name, brand, price, rating, in_stock, (count(*) OVER (?)), (avg(price) OVER (?)), (avg(rating) OVER (?)), (count(*) OVER (?)), (count(*) OVER (?)), (count(*) OVER (?)), (CASE WHEN (price < '1500'::numeric) THEN 'Under $1500'::text ELSE '$1500+'::text END)
   ->  Sort
         Output: id, name, brand, price, rating, in_stock, (count(*) OVER (?)), (avg(price) OVER (?)), (avg(rating) OVER (?)), (count(*) OVER (?)), (count(*) OVER (?)), (count(*) OVER (?)), (CASE WHEN (price < '1500'::numeric) THEN 'Under $1500'::text ELSE '$1500+'::text END)
         Sort Key: products.rating DESC
         ->  WindowAgg
               Output: id, name, brand, price, rating, in_stock, count(*) OVER (?), avg(price) OVER (?), avg(rating) OVER (?), (count(*) OVER (?)), (count(*) OVER (?)), (count(*) OVER (?)), (CASE WHEN (price < '1500'::numeric) THEN 'Under $1500'::text ELSE '$1500+'::text END)
               ->  WindowAgg
                     Output: brand, in_stock, (CASE WHEN (price < '1500'::numeric) THEN 'Under $1500'::text ELSE '$1500+'::text END), id, name, price, rating, (count(*) OVER (?)), (count(*) OVER (?)), count(*) OVER (?)
                     ->  Sort
                           Output: brand, in_stock, (CASE WHEN (price < '1500'::numeric) THEN 'Under $1500'::text ELSE '$1500+'::text END), id, name, price, rating, (count(*) OVER (?)), (count(*) OVER (?))
                           Sort Key: products.brand
                           ->  WindowAgg
                                 Output: brand, in_stock, (CASE WHEN (price < '1500'::numeric) THEN 'Under $1500'::text ELSE '$1500+'::text END), id, name, price, rating, (count(*) OVER (?)), count(*) OVER (?)
                                 ->  Sort
                                       Output: brand, in_stock, (CASE WHEN (price < '1500'::numeric) THEN 'Under $1500'::text ELSE '$1500+'::text END), id, name, price, rating, (count(*) OVER (?))
                                       Sort Key: (CASE WHEN (products.price < '1500'::numeric) THEN 'Under $1500'::text ELSE '$1500+'::text END)
                                       ->  WindowAgg
                                             Output: brand, in_stock, (CASE WHEN (price < '1500'::numeric) THEN 'Under $1500'::text ELSE '$1500+'::text END), id, name, price, rating, count(*) OVER (?)
                                             ->  Sort
                                                   Output: brand, in_stock, (CASE WHEN (price < '1500'::numeric) THEN 'Under $1500'::text ELSE '$1500+'::text END), id, name, price, rating
                                                   Sort Key: products.in_stock
                                                   ->  Custom Scan (ParadeDB Scan) on public.products
                                                         Output: brand, in_stock, CASE WHEN (price < '1500'::numeric) THEN 'Under $1500'::text ELSE '$1500+'::text END, id, name, price, rating
                                                         Table: products
                                                         Index: products_idx
                                                         Exec Method: NormalScanExecState
                                                         Scores: false
                                                         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"laptop","lenient":null,"conjunction_mode":null}}}}
(29 rows)

SELECT 
    id,
    name,
    brand,
    price,
    rating,
    in_stock,
    -- Overall metrics
    COUNT(*) OVER () as total_results,
    AVG(price) OVER () as avg_price,
    AVG(rating) OVER () as avg_rating,
    -- Brand facets
    COUNT(*) OVER (PARTITION BY brand) as brand_count,
    -- Price range facets
    COUNT(*) OVER (PARTITION BY CASE 
        WHEN price < 1500 THEN 'Under $1500'
        ELSE '$1500+'
    END) as price_range_count,
    -- Stock facets
    COUNT(*) OVER (PARTITION BY in_stock) as stock_count
FROM products
WHERE description @@@ 'laptop'
ORDER BY rating DESC
LIMIT 3;
 id |    name     | brand  | price | rating | in_stock | total_results |       avg_price       |     avg_rating     | brand_count | price_range_count | stock_count 
----+-------------+--------+-------+--------+----------+---------------+-----------------------+--------------------+-------------+-------------------+-------------
  1 | MacBook Pro | Apple  |  2499 |    4.8 | t        |             4 | 1849.0000000000000000 | 4.6000000000000000 |           1 |                 3 |           4
  5 | ASUS ROG    | ASUS   |  1899 |    4.7 | t        |             4 | 1849.0000000000000000 | 4.6000000000000000 |           1 |                 3 |           4
  3 | ThinkPad X1 | Lenovo |  1599 |    4.5 | t        |             4 | 1849.0000000000000000 | 4.6000000000000000 |           1 |                 3 |           4
(3 rows)

-- Cleanup
DROP TABLE products CASCADE;
