// Copyright (c) 2023-2025 ParadeDB, Inc.
//
// This file is part of ParadeDB - Postgres for Search and Analytics
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

use crate::api::HashMap;
use crate::gucs;
use crate::postgres::customscan::builders::custom_path::{CustomPathBuilder, Flags};
use crate::postgres::customscan::pdbscan::projections::window_agg::WindowAggregateInfo;
use crate::postgres::customscan::{CreateUpperPathsHookArgs, CustomScan, RelPathlistHookArgs};
use once_cell::sync::Lazy;
use pgrx::{pg_guard, pg_sys, PgList, PgMemoryContexts};
use std::collections::hash_map::Entry;
use std::sync::Mutex;

use crate::nodecast;

// Global storage for window aggregates extracted during planning
// PostgreSQL may copy Query structures during planning, so we can't reliably key by Query pointer.
// Instead, we use a simple "latest" storage since planning is single-threaded per backend.
// The planner hook extracts and stores here, then plan_custom_path retrieves.
pub static EXTRACTED_WINDOW_AGGREGATES: Lazy<Mutex<Option<Vec<WindowAggregateInfo>>>> =
    Lazy::new(|| Mutex::new(None));

unsafe fn add_path(rel: *mut pg_sys::RelOptInfo, mut path: pg_sys::CustomPath) {
    let forced = path.flags & Flags::Force as u32 != 0;
    path.flags ^= Flags::Force as u32; // make sure to clear this flag because it's special to us

    let mut custom_path = PgMemoryContexts::CurrentMemoryContext
        .copy_ptr_into(&mut path, std::mem::size_of_val(&path));

    if (*custom_path).path.parallel_aware {
        // add the partial path since the user-generated plan is parallel aware
        pg_sys::add_partial_path(rel, custom_path.cast());

        // remove all the existing possible paths
        (*rel).pathlist = std::ptr::null_mut();

        // then make another copy of it, increase its costs really, really high and
        // submit it as a regular path too, immediately after clearing out all the other
        // existing possible paths.
        //
        // We don't want postgres to choose this path, but we have to have at least one
        // non-partial path available for it to consider
        let copy = PgMemoryContexts::CurrentMemoryContext
            .copy_ptr_into(&mut path, std::mem::size_of_val(&path));
        (*copy).path.parallel_aware = false;
        (*copy).path.total_cost = 1000000000.0;
        (*copy).path.startup_cost = 1000000000.0;

        // will be added down below
        custom_path = copy.cast();
    } else if forced {
        // remove all the existing possible paths
        (*rel).pathlist = std::ptr::null_mut();
    }

    // add this path for consideration
    pg_sys::add_path(rel, custom_path.cast());
}

pub fn register_rel_pathlist<CS>(_: CS)
where
    CS: CustomScan<Args = RelPathlistHookArgs> + 'static,
{
    unsafe {
        static mut PREV_HOOKS: Lazy<HashMap<std::any::TypeId, pg_sys::set_rel_pathlist_hook_type>> =
            Lazy::new(Default::default);

        #[pg_guard]
        extern "C-unwind" fn __priv_callback<CS>(
            root: *mut pg_sys::PlannerInfo,
            rel: *mut pg_sys::RelOptInfo,
            rti: pg_sys::Index,
            rte: *mut pg_sys::RangeTblEntry,
        ) where
            CS: CustomScan<Args = RelPathlistHookArgs> + 'static,
        {
            unsafe {
                #[allow(static_mut_refs)]
                if let Some(Some(prev_hook)) = PREV_HOOKS.get(&std::any::TypeId::of::<CS>()) {
                    (*prev_hook)(root, rel, rti, rte);
                }

                paradedb_rel_pathlist_callback::<CS>(root, rel, rti, rte);
            }
        }

        #[allow(static_mut_refs)]
        match PREV_HOOKS.entry(std::any::TypeId::of::<CS>()) {
            Entry::Occupied(_) => panic!("{} is already registered", std::any::type_name::<CS>()),
            Entry::Vacant(entry) => entry.insert(pg_sys::set_rel_pathlist_hook),
        };

        pg_sys::set_rel_pathlist_hook = Some(__priv_callback::<CS>);

        pg_sys::RegisterCustomScanMethods(CS::custom_scan_methods())
    }
}

/// Although this hook function can be used to examine, modify, or remove paths generated by the
/// core system, a custom scan provider will typically confine itself to generating CustomPath
/// objects and adding them to rel using add_path. The custom scan provider is responsible for
/// initializing the CustomPath object, which is declared like this:
#[pg_guard]
pub extern "C-unwind" fn paradedb_rel_pathlist_callback<CS>(
    root: *mut pg_sys::PlannerInfo,
    rel: *mut pg_sys::RelOptInfo,
    rti: pg_sys::Index,
    rte: *mut pg_sys::RangeTblEntry,
) where
    CS: CustomScan<Args = RelPathlistHookArgs> + 'static,
{
    unsafe {
        if !gucs::enable_custom_scan() {
            return;
        }

        let Some(path) = CS::create_custom_path(CustomPathBuilder::new(
            root,
            rel,
            RelPathlistHookArgs {
                root,
                rel,
                rti,
                rte,
            },
        )) else {
            return;
        };

        add_path(rel, path)
    }
}

pub fn register_upper_path<CS>(_: CS)
where
    CS: CustomScan<Args = CreateUpperPathsHookArgs> + 'static,
{
    unsafe {
        static mut PREV_HOOKS: Lazy<
            HashMap<std::any::TypeId, pg_sys::create_upper_paths_hook_type>,
        > = Lazy::new(Default::default);

        #[pg_guard]
        extern "C-unwind" fn __priv_callback<CS>(
            root: *mut pg_sys::PlannerInfo,
            stage: pg_sys::UpperRelationKind::Type,
            input_rel: *mut pg_sys::RelOptInfo,
            output_rel: *mut pg_sys::RelOptInfo,
            extra: *mut ::std::os::raw::c_void,
        ) where
            CS: CustomScan<Args = CreateUpperPathsHookArgs> + 'static,
        {
            unsafe {
                #[allow(static_mut_refs)]
                if let Some(Some(prev_hook)) = PREV_HOOKS.get(&std::any::TypeId::of::<CS>()) {
                    (*prev_hook)(root, stage, input_rel, output_rel, extra);
                }

                paradedb_upper_paths_callback::<CS>(root, stage, input_rel, output_rel, extra);
            }
        }

        #[allow(static_mut_refs)]
        match PREV_HOOKS.entry(std::any::TypeId::of::<CS>()) {
            Entry::Occupied(_) => panic!("{} is already registered", std::any::type_name::<CS>()),
            Entry::Vacant(entry) => entry.insert(pg_sys::create_upper_paths_hook),
        };

        pg_sys::create_upper_paths_hook = Some(__priv_callback::<CS>);

        pg_sys::RegisterCustomScanMethods(CS::custom_scan_methods())
    }
}

#[pg_guard]
pub extern "C-unwind" fn paradedb_upper_paths_callback<CS>(
    root: *mut pg_sys::PlannerInfo,
    stage: pg_sys::UpperRelationKind::Type,
    input_rel: *mut pg_sys::RelOptInfo,
    output_rel: *mut pg_sys::RelOptInfo,
    extra: *mut ::std::os::raw::c_void,
) where
    CS: CustomScan<Args = CreateUpperPathsHookArgs> + 'static,
{
    if stage != pg_sys::UpperRelationKind::UPPERREL_GROUP_AGG {
        return;
    }

    if !gucs::enable_aggregate_custom_scan() {
        return;
    }

    unsafe {
        let Some(path) = CS::create_custom_path(CustomPathBuilder::new(
            root,
            output_rel,
            CreateUpperPathsHookArgs {
                root,
                stage,
                input_rel,
                output_rel,
                extra,
            },
        )) else {
            return;
        };

        add_path(output_rel, path)
    }
}

/// Register a global planner hook to intercept and modify queries before planning.
/// This is called once during extension initialization and affects all queries.
pub unsafe fn register_window_function_hook() {
    static mut PREV_PLANNER_HOOK: pg_sys::planner_hook_type = None;

    PREV_PLANNER_HOOK = pg_sys::planner_hook;
    pg_sys::planner_hook = Some(paradedb_planner_hook);
}

/// Planner hook that replaces WindowFunc nodes before PostgreSQL processes them
/// Only replaces window functions if the query will be handled by our custom scans
#[pg_guard]
unsafe extern "C-unwind" fn paradedb_planner_hook(
    parse: *mut pg_sys::Query,
    query_string: *const ::core::ffi::c_char,
    cursor_options: ::core::ffi::c_int,
    bound_params: pg_sys::ParamListInfo,
) -> *mut pg_sys::PlannedStmt {
    // Check if this is a SELECT query with window functions that we can handle
    if !parse.is_null() && (*parse).commandType == pg_sys::CmdType::CMD_SELECT {
        // Debug: Count RTEs and check for subqueries
        let rte_count = if !(*parse).rtable.is_null() {
            PgList::<pg_sys::RangeTblEntry>::from_pg((*parse).rtable).len()
        } else {
            0
        };

        let has_window_funcs = query_has_window_functions(parse);
        let has_search_op = query_has_search_operator(parse);

        pgrx::warning!(
            "planner_hook: SELECT query (RTEs={}) - has_window_funcs={}, has_search_op={}",
            rte_count,
            has_window_funcs,
            has_search_op
        );

        if has_window_funcs && has_search_op {
            pgrx::warning!(
                "planner_hook: Found window functions in search query - replacing with window_func(json)"
            );

            // Extract and replace window functions recursively (including subqueries)
            replace_windowfuncs_recursively(parse);
        }
    }

    // Call the previous planner hook or standard planner
    static mut PREV_PLANNER_HOOK: pg_sys::planner_hook_type = None;
    if let Some(prev_hook) = PREV_PLANNER_HOOK {
        prev_hook(parse, query_string, cursor_options, bound_params)
    } else {
        pg_sys::standard_planner(parse, query_string, cursor_options, bound_params)
    }
}

/// Check if the target list contains any window functions
unsafe fn has_window_functions(target_list: *mut pg_sys::List) -> bool {
    let tlist = PgList::<pg_sys::TargetEntry>::from_pg(target_list);
    for te in tlist.iter_ptr() {
        if nodecast!(WindowFunc, T_WindowFunc, (*te).expr).is_some() {
            return true;
        }
    }
    false
}

/// Check if the query (or any subquery) contains window functions
unsafe fn query_has_window_functions(parse: *mut pg_sys::Query) -> bool {
    if parse.is_null() {
        return false;
    }

    // Check the current query's target list
    if !(*parse).targetList.is_null() && has_window_functions((*parse).targetList) {
        pgrx::warning!("query_has_window_functions: Found window functions in current query");
        return true;
    }

    // Check subqueries in RTEs
    if !(*parse).rtable.is_null() {
        let rtable = PgList::<pg_sys::RangeTblEntry>::from_pg((*parse).rtable);
        pgrx::warning!(
            "query_has_window_functions: Checking {} RTEs for subquery window functions",
            rtable.len()
        );
        for (idx, rte) in rtable.iter_ptr().enumerate() {
            if (*rte).rtekind == pg_sys::RTEKind::RTE_SUBQUERY && !(*rte).subquery.is_null() {
                pgrx::warning!(
                    "  RTE {}: Found subquery, checking for window functions recursively",
                    idx
                );
                if query_has_window_functions((*rte).subquery) {
                    pgrx::warning!("  RTE {}: Subquery contains window functions!", idx);
                    return true;
                }
            }
        }
    }

    false
}

/// Check if the query contains the @@@ search operator
/// This indicates that our custom scans will likely handle this query
unsafe fn query_has_search_operator(parse: *mut pg_sys::Query) -> bool {
    use crate::api::operator::{anyelement_query_input_opoid, anyelement_text_opoid};

    let searchqueryinput_opno = anyelement_query_input_opoid();
    let text_opno = anyelement_text_opoid();

    pgrx::warning!(
        "query_has_search_operator: Looking for opno={} or {}",
        searchqueryinput_opno,
        text_opno
    );

    // Check WHERE clause (jointree->quals)
    if !(*parse).jointree.is_null() {
        let jointree = (*parse).jointree;
        pgrx::warning!("query_has_search_operator: jointree is not null");
        if !(*jointree).quals.is_null() {
            pgrx::warning!("query_has_search_operator: quals is not null, checking...");
            if expr_contains_any_operator((*jointree).quals, &[searchqueryinput_opno, text_opno]) {
                pgrx::warning!("query_has_search_operator: Found @@@ in WHERE clause");
                return true;
            }
        } else {
            pgrx::warning!("query_has_search_operator: quals is null");
        }
    } else {
        pgrx::warning!("query_has_search_operator: jointree is null");
    }

    // Check HAVING clause
    if !(*parse).havingQual.is_null() {
        pgrx::warning!("query_has_search_operator: Checking HAVING clause");
        if expr_contains_any_operator((*parse).havingQual, &[searchqueryinput_opno, text_opno]) {
            pgrx::warning!("query_has_search_operator: Found @@@ in HAVING clause");
            return true;
        }
    }

    // Check if any RTEs contain subqueries with @@@ operators
    if !(*parse).rtable.is_null() {
        let rtable = PgList::<pg_sys::RangeTblEntry>::from_pg((*parse).rtable);
        pgrx::warning!(
            "query_has_search_operator: Checking {} RTEs for subqueries",
            rtable.len()
        );
        for (idx, rte) in rtable.iter_ptr().enumerate() {
            if (*rte).rtekind == pg_sys::RTEKind::RTE_SUBQUERY && !(*rte).subquery.is_null() {
                pgrx::warning!("  RTE {}: Found subquery, checking recursively", idx);
                if query_has_search_operator((*rte).subquery) {
                    pgrx::warning!("  RTE {}: Subquery contains @@@!", idx);
                    return true;
                }
            }
        }
    }

    pgrx::warning!("query_has_search_operator: @@@ operator not found");
    false
}

/// Recursively check if an expression tree contains any of the specified operators
unsafe fn expr_contains_any_operator(
    node: *mut pg_sys::Node,
    target_opnos: &[pg_sys::Oid],
) -> bool {
    if node.is_null() {
        return false;
    }

    let node_type = (*node).type_;
    pgrx::warning!("expr_contains_operator: Checking node type={:?}", node_type);

    match node_type {
        pg_sys::NodeTag::T_OpExpr => {
            let opexpr = node as *mut pg_sys::OpExpr;
            pgrx::warning!(
                "expr_contains_operator: Found OpExpr with opno={}",
                (*opexpr).opno
            );
            if target_opnos.contains(&(*opexpr).opno) {
                pgrx::warning!("expr_contains_operator: MATCH! Found target operator");
                return true;
            }
            // Check arguments
            if !(*opexpr).args.is_null() {
                let args = PgList::<pg_sys::Node>::from_pg((*opexpr).args);
                for arg in args.iter_ptr() {
                    if expr_contains_any_operator(arg, target_opnos) {
                        return true;
                    }
                }
            }
        }
        pg_sys::NodeTag::T_BoolExpr => {
            let boolexpr = node as *mut pg_sys::BoolExpr;
            pgrx::warning!("expr_contains_operator: Found BoolExpr, checking args");
            if !(*boolexpr).args.is_null() {
                let args = PgList::<pg_sys::Node>::from_pg((*boolexpr).args);
                for arg in args.iter_ptr() {
                    if expr_contains_any_operator(arg, target_opnos) {
                        return true;
                    }
                }
            }
        }
        pg_sys::NodeTag::T_RestrictInfo => {
            // RestrictInfo wraps the actual clause
            let rinfo = node as *mut pg_sys::RestrictInfo;
            pgrx::warning!("expr_contains_operator: Found RestrictInfo, unwrapping");
            if !(*rinfo).clause.is_null() {
                return expr_contains_any_operator(
                    (*rinfo).clause as *mut pg_sys::Node,
                    target_opnos,
                );
            }
        }
        _ => {
            pgrx::warning!(
                "expr_contains_operator: Unhandled node type={:?}",
                node_type
            );
        }
    }

    false
}

/// Recursively replace window functions in the query and all subqueries
unsafe fn replace_windowfuncs_recursively(parse: *mut pg_sys::Query) {
    if parse.is_null() {
        return;
    }

    // Replace window functions in current query
    let window_aggs = extract_window_functions(parse);
    if !window_aggs.is_empty() {
        replace_windowfuncs_in_query(parse, &window_aggs);
        pgrx::warning!(
            "replace_windowfuncs_recursively: Replaced {} WindowFunc nodes in current query",
            window_aggs.len()
        );
    }

    // Recursively process subqueries in RTEs
    if !(*parse).rtable.is_null() {
        let rtable = PgList::<pg_sys::RangeTblEntry>::from_pg((*parse).rtable);
        for (idx, rte) in rtable.iter_ptr().enumerate() {
            if (*rte).rtekind == pg_sys::RTEKind::RTE_SUBQUERY && !(*rte).subquery.is_null() {
                pgrx::warning!(
                    "replace_windowfuncs_recursively: Processing subquery in RTE {}",
                    idx
                );
                replace_windowfuncs_recursively((*rte).subquery);
            }
        }
    }
}

/// Replace WindowFunc nodes in the Query's target list with placeholder functions
unsafe fn replace_windowfuncs_in_query(
    parse: *mut pg_sys::Query,
    window_aggs: &[WindowAggregateInfo],
) {
    use crate::api::window_function::window_func_oid;
    use pgrx::IntoDatum;

    if (*parse).targetList.is_null() {
        return;
    }

    let original_tlist = PgList::<pg_sys::TargetEntry>::from_pg((*parse).targetList);
    let mut new_targetlist = PgList::<pg_sys::TargetEntry>::new();
    let window_func_procid = window_func_oid();
    let mut replaced_count = 0;

    // Create a map from target entry index to window aggregate info for quick lookup
    let window_agg_map: HashMap<usize, &WindowAggregateInfo> = window_aggs
        .iter()
        .map(|agg| (agg.target_entry_index, agg))
        .collect();

    for (idx, te) in original_tlist.iter_ptr().enumerate() {
        if let Some(_window_func) = nodecast!(WindowFunc, T_WindowFunc, (*te).expr) {
            // Create a flat copy of the target entry
            let new_te = pg_sys::flatCopyTargetEntry(te);

            // Get the window aggregate info for this target entry
            if let Some(agg_info) = window_agg_map.get(&idx) {
                // Serialize the window aggregate info to JSON
                let json = serde_json::to_string(agg_info)
                    .expect("Failed to serialize WindowAggregateInfo");

                // Create a Const node for the JSON string
                let json_cstring = std::ffi::CString::new(json).expect("Invalid JSON string");
                let json_text = pg_sys::cstring_to_text(json_cstring.as_ptr());
                let json_datum = pg_sys::Datum::from(json_text as usize);

                // Create an argument list with the JSON string
                let mut args = PgList::<pg_sys::Node>::new();
                let json_const = pg_sys::makeConst(
                    pg_sys::TEXTOID,
                    -1,
                    pg_sys::DEFAULT_COLLATION_OID,
                    -1,
                    json_datum,
                    false, // not null
                    false, // not passed by value (text is varlena)
                );
                args.push(json_const.cast());

                // Create a FuncExpr that calls paradedb.window_func(json)
                let funcexpr = pg_sys::makeFuncExpr(
                    window_func_procid,
                    agg_info.result_type_oid,
                    args.into_pg(),
                    pg_sys::InvalidOid,
                    pg_sys::InvalidOid,
                    pg_sys::CoercionForm::COERCE_EXPLICIT_CALL,
                );

                // Replace the WindowFunc with our placeholder FuncExpr
                (*new_te).expr = funcexpr.cast();
                new_targetlist.push(new_te);
                replaced_count += 1;

                pgrx::warning!(
                    "planner_hook: Replaced WindowFunc at resno {} with window_func(json)",
                    (*te).resno
                );
            } else {
                pgrx::warning!(
                    "planner_hook: WARNING: No window aggregate info for index {}",
                    idx
                );
                // Still copy the entry but don't replace it
                new_targetlist.push(te);
            }
        } else {
            // For non-WindowFunc entries, just make a flat copy
            let copied_te = pg_sys::flatCopyTargetEntry(te);
            new_targetlist.push(copied_te);
        }
    }

    pgrx::warning!(
        "planner_hook: Replaced {} WindowFunc nodes in Query with window_func calls",
        replaced_count
    );
    (*parse).targetList = new_targetlist.into_pg();
}

/// Get the Oid of the now() function to use as a placeholder
pub unsafe fn placeholder_procid() -> pg_sys::Oid {
    use pgrx::IntoDatum;
    pgrx::direct_function_call::<pg_sys::Oid>(pg_sys::regprocedurein, &[c"now()".into_datum()])
        .expect("the `now()` function should exist")
}

/// Extract window functions, store in global cache, and return them for replacement
/// This is called in the planner hook before replacing WindowFunc nodes
unsafe fn extract_window_functions(parse: *mut pg_sys::Query) -> Vec<WindowAggregateInfo> {
    use crate::postgres::customscan::pdbscan::projections::window_agg;
    use crate::postgres::rel_get_bm25_index;

    // Get the bm25_index for proper FILTER extraction
    // We need to find the relation OID from the query's rtable
    assert!(
        !(*parse).rtable.is_null(),
        "Query rtable should not be null"
    );

    let rtable = PgList::<pg_sys::RangeTblEntry>::from_pg((*parse).rtable);
    // Look for the first plain relation with a bm25 index
    let mut bm25_index_opt = None;
    let mut heap_rti = 1;
    for (idx, rte) in rtable.iter_ptr().enumerate() {
        if (*rte).rtekind == pg_sys::RTEKind::RTE_RELATION {
            if let Some((_, bm25_index)) = rel_get_bm25_index((*rte).relid) {
                bm25_index_opt = Some(bm25_index);
                heap_rti = (idx + 1) as pg_sys::Index;
                break;
            }
        }
    }

    // We should always find a bm25_index since we only get here when has_search_op=true
    let bm25_index = bm25_index_opt.expect("Should find bm25_index when query has @@@ operator");

    // Extract window aggregates with full context
    let window_aggs = window_agg::extract_window_aggregates_with_context(
        (*parse).targetList,
        (*parse).windowClause,
        heap_rti,
        &bm25_index,
        std::ptr::null_mut(), // root not available yet in planner_hook
    );

    if window_aggs.is_empty() {
        pgrx::warning!("planner_hook: No extractable window aggregates found");
    } else {
        pgrx::warning!(
            "planner_hook: Extracted {} window aggregates",
            window_aggs.len()
        );

        // Store in global "latest" storage for retrieval in plan_custom_path
        // (PostgreSQL may copy the Query, so we can't key by pointer)
        let mut storage = EXTRACTED_WINDOW_AGGREGATES
            .lock()
            .expect("Failed to lock EXTRACTED_WINDOW_AGGREGATES");
        *storage = Some(window_aggs.clone());
        pgrx::warning!("planner_hook: Stored window aggregates in global storage");
    }

    window_aggs
}

/// Retrieve and clear window aggregates from the global storage
/// Returns None if no aggregates were stored
pub unsafe fn take_extracted_window_aggregates() -> Option<Vec<WindowAggregateInfo>> {
    let mut storage = EXTRACTED_WINDOW_AGGREGATES
        .lock()
        .expect("Failed to lock EXTRACTED_WINDOW_AGGREGATES");
    let result = storage.take();
    if result.is_some() {
        pgrx::warning!("Retrieved window aggregates from global storage");
    }
    result
}

/// Extract window aggregates from paradedb.window_func(json) calls in the target list
/// This is called during custom scan planning to deserialize the window aggregate info
/// that was embedded during the planner hook
pub unsafe fn extract_window_aggregates_from_targetlist(
    target_list: *mut pg_sys::List,
) -> Vec<WindowAggregateInfo> {
    use crate::api::window_function::window_func_oid;
    use pgrx::FromDatum;

    let mut window_aggs = Vec::new();
    if target_list.is_null() {
        return window_aggs;
    }

    let window_func_procid = window_func_oid();
    let tlist = PgList::<pg_sys::TargetEntry>::from_pg(target_list);

    pgrx::warning!(
        "extract_window_aggregates_from_targetlist: Scanning {} target entries, looking for funcid={}",
        tlist.len(),
        window_func_procid
    );

    for (idx, te) in tlist.iter_ptr().enumerate() {
        let node_type = (*(*te).expr).type_;
        pgrx::warning!("  Entry {}: node type={:?}", idx, node_type);

        // Check if this is a FuncExpr calling window_func
        if let Some(funcexpr) = nodecast!(FuncExpr, T_FuncExpr, (*te).expr) {
            pgrx::warning!(
                "  Entry {}: Found FuncExpr with funcid={}",
                idx,
                (*funcexpr).funcid
            );
            if (*funcexpr).funcid == window_func_procid {
                // This is our window_func placeholder
                // Extract the JSON argument
                if !(*funcexpr).args.is_null() {
                    let args = PgList::<pg_sys::Node>::from_pg((*funcexpr).args);
                    if let Some(first_arg) = args.get_ptr(0) {
                        if let Some(const_node) = nodecast!(Const, T_Const, first_arg) {
                            // Extract the text datum and deserialize
                            if !(*const_node).constisnull {
                                let json_text = pg_sys::Datum::from((*const_node).constvalue);
                                if let Some(json_str) = String::from_datum(json_text, false) {
                                    match serde_json::from_str::<WindowAggregateInfo>(&json_str) {
                                        Ok(window_agg) => {
                                            pgrx::warning!(
                                                "Deserialized window aggregate from target entry {}",
                                                idx
                                            );
                                            window_aggs.push(window_agg);
                                        }
                                        Err(e) => {
                                            pgrx::warning!(
                                                "Failed to deserialize window aggregate: {}",
                                                e
                                            );
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    window_aggs
}
