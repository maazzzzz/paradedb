<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Benchmark Results</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
  <!-- Zoom plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.0" defer></script>
  <style>
    .chart-container canvas { min-height: 300px; }
    .toggle-switch { display: flex; align-items: center; margin-bottom: 0.5rem; }
    .toggle-switch input { margin-right: 0.5rem; }
    .reset-btn { padding: 0.25rem 0.75rem; background: #4299e1; color: white; border-radius: 0.375rem; cursor: pointer; }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 p-6">
  <div class="max-w-7xl mx-auto">
    <header class="mb-10">
      <h1 class="text-4xl font-bold">ParadeDB Stressgres Benchmark Results</h1>
      <p class="text-gray-600 mt-2">Organized by config file and metric.</p>
    </header>
    <div id="charts" class="space-y-12"></div>
  </div>

  <script>
    async function initCharts() {
      try {
        // Load data.js
        const res = await fetch('https://paradedb.github.io/paradedb/stressgres/data.js');
        const scriptText = await res.text(); eval(scriptText);
        Chart.register(ChartZoom);

        const rawData = window.BENCHMARK_DATA?.entries || {};
        const container = document.getElementById('charts');
        if (!Object.keys(rawData).length) {
          container.innerHTML = '<p class="text-red-500">No data.</p>';
          return;
        }

        // Collect all unique commit IDs
        const allEntries = Object.values(rawData).flat();
        const uniqueIds = Array.from(
          new Set(allEntries.map(e => e.commit.id))
        );
        const hashMap = {};

        // Asynchronously resolve PR number and title for each commit
        const fetchPrInfo = async () => {
          for (const fullId of uniqueIds) {
            const short = fullId.slice(0,7);
            try {
              const searchRes = await fetch(
                `https://api.github.com/search/issues?q=${short}+repo:paradedb/paradedb+type:pr`
              );
              const data = await searchRes.json();
              if (data.items && data.items.length) {
                const pr = data.items[0];
                hashMap[short] = `#${pr.number}: ${pr.title}`;
              } else {
                hashMap[short] = short;
              }
            } catch {
              hashMap[short] = short;
            }
          }
        };
        await fetchPrInfo();

        // Group by filename
        const fileGroups = {};
        Object.entries(rawData).forEach(([category, entries]) => {
          const parts = category.split(' ');
          const filename = parts[1] || category;
          fileGroups[filename] = (fileGroups[filename] || []).concat(entries);
        });

        // Create charts per file and metric
        Object.entries(fileGroups).forEach(([filename, entries]) => {
          const section = document.createElement('section');
          section.className = 'bg-white p-6 rounded-xl shadow-lg';
          const fileHeading = document.createElement('h2');
          fileHeading.className = 'text-2xl font-semibold mb-4';
          fileHeading.textContent = filename;
          section.appendChild(fileHeading);

          // Group by metric (suffix of bench name)
          const metricGroups = {};
          entries.forEach(entry => {
            const commitTs = new Date(entry.commit.timestamp).getTime();
            entry.benches.forEach(b => {
              const parts = b.name.split(' - ');
              const metric = parts[parts.length - 1];
              metricGroups[metric] = metricGroups[metric] || [];
              metricGroups[metric].push({
                name: b.name,
                unit: b.unit,
                commitTs,
                runTs: entry.date,
                fullId: entry.commit.id,
                hash: entry.commit.id.slice(0,7),
                value: b.value
              });
            });
          });

          Object.entries(metricGroups).forEach(([metric, benchData]) => {
            // Heading
            const graphHeading = document.createElement('h3');
            graphHeading.className = 'text-xl font-semibold mt-6 mb-2';
            graphHeading.textContent = metric;
            section.appendChild(graphHeading);

            // Unique sorted runs
            const runKeys = Array.from(new Set(
              benchData.map(d => `${d.commitTs}|${d.runTs}|${d.hash}`)
            ));
            const runs = runKeys.map(key => {
              const [commitTs, runTs, hash] = key.split('|');
              return { commitTs: Number(commitTs), runTs: Number(runTs), hash };
            }).sort((a,b) => a.commitTs - b.commitTs || a.runTs - b.runTs);

            // Prepare full and truncated labels
            const fullLabels = runs.map(r => hashMap[r.hash] || r.hash);
            const labels = fullLabels.map(l => l.length > 25 ? l.slice(0,25) + 'â€¦' : l);

            // Build dataset values aligned to runs
            const seriesMap = {};
            benchData.forEach(d => {
              seriesMap[d.name] = seriesMap[d.name] || [];
              const idx = runs.findIndex(r => r.commitTs===d.commitTs && r.runTs===d.runTs && r.hash===d.hash);
              seriesMap[d.name][idx] = d.value;
            });
            const datasets = Object.entries(seriesMap).map(([name, data]) => ({
              label: name,
              data,
              original: data.slice(),
              fill: false,
              tension: 0.4,
              borderWidth: 2
            }));

            // Chart container
            const chartWrapper = document.createElement('div');
            chartWrapper.className = 'mb-8 chart-container';
            const toggleRow = document.createElement('div');
            toggleRow.className = 'toggle-switch';
            toggleRow.innerHTML = '<label><input type="checkbox" class="norm-toggle"/><span>Normalize to First Value</span></label>';
            chartWrapper.appendChild(toggleRow);
            const canvas = document.createElement('canvas');
            chartWrapper.appendChild(canvas);
            const btnRow = document.createElement('div');
            btnRow.className = 'flex justify-start mt-2';
            const resetBtn = document.createElement('button');
            resetBtn.textContent = 'Zoom Out';
            resetBtn.className = 'reset-btn';
            btnRow.appendChild(resetBtn);
            chartWrapper.appendChild(btnRow);
            section.appendChild(chartWrapper);

            const yLabel = benchData[0]?.unit || '';
            const chart = new Chart(canvas.getContext('2d'), {
              type: 'line',
              data: { labels, datasets },
              options: {
                responsive: true,
                scales: {
                  x: { ticks: { maxRotation: 33, minRotation: 33 } },
                  y: { title: { display: true, text: yLabel } }
                },
                plugins: {
                  tooltip: {
                    mode: 'index', intersect: false,
                    callbacks: {
                      title: items => fullLabels[items[0].dataIndex]
                    }
                  },
                  zoom: { zoom: { drag: { enabled: true } } }
                }
              }
            });
            chart.normalized = false;

            // Normalize toggle
            toggleRow.querySelector('.norm-toggle').addEventListener('change', e => {
              const norm = e.target.checked;
              chart.resetZoom();
              chart.normalized = norm;
              chart.data.datasets.forEach(ds => {
                ds.data = norm && ds.original[0] ? ds.original.map(v => v!=null ? v/ds.original[0] : null) : ds.original.slice();
              });
              chart.update();
            });
            // Zoom out button
            resetBtn.addEventListener('click', () => chart.resetZoom());
            // Hovertip hide/show during drag
            canvas.addEventListener('mousedown', () => { chart.options.plugins.tooltip.enabled = false; chart.update('none'); });
            canvas.addEventListener('mouseup', () => { chart.options.plugins.tooltip.enabled = true; chart.update('none'); });
          });

          container.appendChild(section);
        });
      } catch (err) {
        console.error(err);
        document.getElementById('charts').innerHTML = '<p class="text-red-500">Failed to load benchmark data.</p>';
      }
    }
    document.addEventListener('DOMContentLoaded', initCharts);
  </script>
</body>
</html>
